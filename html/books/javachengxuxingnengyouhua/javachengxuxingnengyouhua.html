<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <!--添加自适应标签-->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" shrink-to-fit=no">
        <title>甜先森</title>
        <!--title上面添加icon-->
        <link rel="shortcut icon" href="../../../images/head/head.png"/>
    </head>
    <style type="text/css">
        .contents img{margin-left: 18%}
    </style>

    <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
    <link href="../../../product/bootstrap/css/bootstrap.css" type="text/css" rel="stylesheet">
    <link href="../../../css/quanzhan/pachong/pachong.css" type="text/css" rel="stylesheet">

<body>
    <div class="containers">
        <div class="col-md-12">
            <div class="contents">
                <!--提示信息-->
                <div class="bs-example bs-example-standalone" data-example-id="dismissible-alert-js">
                    <div class="alert alert-info alert-dismissible fade in" role="alert">
                        <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button>
                        <strong>注意：参照 java程序性能优化</strong>
                    </div>
                </div>
                <figure class="highlight">
                    <pre>
                        <code class="language-html" data-lang="html">
第一章 java性能调优概述
    性能瓶颈：
        磁盘IO、网络、CPU、内存、数据库、锁竞争、异常
    调优方向：
        设计方案调优、代码调优、JVM调优、数据库调优、操作系统调优
第二章 设计优化
    2.1.善用设计模式
        2.1.1.单例设计模式 (有用)
            减少对象创建，时间花费和内存消耗
        2.1.2.代理设计模式
        2.1.3.享元设计模式
            复用大对象，节省内存空间，对象创建时间
        2.1.4.装饰者设计模式 (有用)
            动态的添加对象的功能
        2.1.5.观察者设计模式 (有用)
            当一个对象的行为依赖于另外一个对象的状态时使用
    2.2.缓冲、缓存、对象池
    2.3.并行 (Thread对象和Runnable接口)
第三章 java程序优化
    3.1.字符串优化处理
        3.1.1.final不变性、常量池
    3.2.高效字符串分割
        3.2.1.使用StringTokenizer,indexOf代替split()
        3.2.2.stringbuffer/stringbuilder选择，设置初始容量值，避免容量扩容
    3.3.慎用try()catch(){}
    3.4.位运算代替乘除法
    3.5.静态方法替代实例方法
    3.6.核心数据结构
        3.6.1.List数组，设置默认初始化大小，可以提高效率
        3.6.2.原始for循环才是效率最高的 (未添加语法糖) for(int i=0,len=arr.length;i<len;i++){}
        3.6.3.Map中主要的HahsMap，HashTable，LinkedHashMap
        3.6.4.LinkedHashMap是基于元素进入集合的顺序或者被访问的先后顺序排序，TreeMap是基于元素的固有顺序进行排序(comparator)
        3.6.5.Set是基于Map的封装
    3.7.使用NIO提升性能
    3.8.软引用和弱引用(weakHashMap)非常适合保存那些可有可无的缓存数据
    3.9.使用System,arraycopy()或者Arrays.copyof()   // Arrays.copyof()会新创建一个新数组调用System.arraycopy()
    3.10.使用Buffer或者NIO进行IO操作
    3.11.工具类应该使用static静态方法，而不是实例方法
第四章 并行程序开发及优化
    4.1.并行程序设计模式
        Future模式，Master-worker模式，生产者-消费者模式
    4.2.Master-worker模式
        -- 待深入研究
    4.3.生产者-消费者模式
        -- 待深入研究
    4.4.JDK多任务执行框架 (Executor框架)
        生产环境中使用线程，必须对其加一控制和管理
        线程池的基本功能就是进行线程的复用
    4.5.Executor框架
        4.5.1.线程池工厂方法
            newFixedThreadPool()：返回一个固定线程数量的线程池
            newSingleThreadExecutor()：返回一个只有一个线程的线程池
            newCachedThreadPool()：返回一个可根据实际情况调整线程数量的线程池
            newScheduledThreadPool()：返回一个ScheduledExecutorService对象
        4.5.2.自定义线程池
            ThreadPoolExecutor()：可扩展的线程池
    4.6.JDK并发数据结构 (适合读多写少的高并发场景)
        4.6.1.并发List
            vector、copyOnWriteArrayList、Collections.synchronizedList(List list)
        4.6.2.并发Set
            copyOnWriteArraySet
            public static <T> Set<T> synchronizedSet(Set<T> s)  // 得到线程安全的set
        4.6.3.并发Map
            synchronized()：方法可以得到一个线程安全的Map
            concurentHashMap
        4.6.4.并发Queue
            ConcurrentLinkedQueue 高性能队列
            BlockingQueue 阻塞队列 (生产者-消费者使用场景)
        4.6.5.并发Deque 双端队列
        4.6.6.并发控制方法
            volatile、synchronized、Lock、readWriteLock (读写锁：并行读)
            condition对象、semaphore信号量(限流)、threadlocal
        4.6.7.锁性能优化
            减少锁的持有时间、减小锁粒度(锁定对象的范围)、读写锁替换独占锁(锁分离思想)
            锁粗话(合并多个锁操作)、自旋锁、锁消除、锁偏向、cas(乐观锁)
        4.6.8.Amino框架 (cas数据结构)
            List、set、树、图(有向图/无向图)、任务调度
    4.7.协程
        4.7.1.kilim框架
第五章 JVM调优
                        </code>
                    </pre>
                </figure>
            </div>
        </div>
    </div>
</body>
    <!--引入外部js文件-->
    <!--jquery-->
    <script src="../../../js/index/jquery-3.3.1.min.js"></script>
    <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
    <script src="../../../product/bootstrap/js/bootstrap.min.js"></script>
</html>
