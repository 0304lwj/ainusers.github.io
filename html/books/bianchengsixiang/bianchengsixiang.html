<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <!--添加自适应标签-->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" shrink-to-fit=no">
        <title>甜先森</title>
        <!--title上面添加icon-->
        <link rel="shortcut icon" href="../../../images/head/head.png"/>
    </head>
    <style type="text/css">
        .contents img{margin-left: 18%}
    </style>

    <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
    <link href="../../../product/bootstrap/css/bootstrap.css" type="text/css" rel="stylesheet">
    <link href="../../../css/quanzhan/pachong/pachong.css" type="text/css" rel="stylesheet">

<body>
    <div class="containers">
        <div class="col-md-12">
            <div class="contents">
                <!--提示信息-->
                <div class="bs-example bs-example-standalone" data-example-id="dismissible-alert-js">
                    <div class="alert alert-info alert-dismissible fade in" role="alert">
                        <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button>
                        <strong>注意：参照java编程思想(第四版)</strong>
                    </div>
                </div>
                <figure class="highlight">
                    <pre>
                        <code class="language-html" data-lang="html">
第2章 万物皆对象
    1.java通过“引用”来操控对象
    2.创建的对象存储在1)寄存器 2)堆栈 3)堆 4)常量储存 5)非RAM存储
    3.new创建的对象存储在“堆”中
    4.基本数据类型存储在“堆栈”中
    5.高精度数据类型：BigInteger,BigDecimal
    6.一个类是由变量和方法组合而成的
    7.数据类型的默认值(boolean:false,int:非0)
    8.当不需要返回参数的时候使用void
    9.导入依赖类库import java.util.ArrayList
    10.static关键字，修饰通用变量/方法
    11.编码风格：类，方法，成员变量，以及对象引用均采用驼峰命名法
第3章 操作符
    1.优先级：string计算，会将+号后非string类型元素转换为string类型
    2.赋值：=右边的值赋值给左边，相应的引用指向也将更改
    3.自动递增/递减：([++a/--a]表示先执行运算再生成值),([a++/a--]表示先生成值再执行运算)
    4.==比较为对象的引用以及基本数据类型的值，equals比较的是对象的值(默认比较引用)
    5.巧妙利用短路特性(test1(0) && test(2) && test(3)当判断式为true && false时，第三个表达式将不会计算)，也可获得性能提升
    6.按位操作符：1 & 1 = true ? 1 : 0、1 | 0 = true？ 1 ： 0 (均为0才为0)、1 ^ 0 = true ? 1 : 0、1 ~ = 0 (取反)
    7.移位操作符：只能处理整数类型(增码，反码，补码)
    8.三元运算符：bolean ? true : false
    9.按位与/按位或(&/|)，逻辑与/逻辑或(&&/||)
    10.类型转换(截尾[double/float转换为int][29.7转换为int=29]),(舍入[Math.round(29.7)])
    11.数据类型提升：计算将取决于大数据类型(char/byte/short计算会自动提升为int)，(float*double=double),(int+long=long)
    12.java中没有sizeOf()
    12.java中没有goto
第4章 控制执行流程
    1.逗号操作符
        for(int i=1,j=i+10; i<5; i++,j=i*2){
            System.out.println("i = "+ i + j = " + j );
        }
    2.foreach
        for(Object x : data){}
第5章 初始化与清理
    1.构造器(类使用前，对象得到初始化)：
        class Rock (){
            Rock (){
            }
        }
    2."初始化"和“创建”类，在java中为捆绑关系，没有明显的调用关系
    3.重载
        void info () {}
        void info (String s) {}
    4.java类会自动创建无参构造器，自定义构造器(无论是否有参数)均不会创建
    5.垃圾回收：
        (1)对象可能不被垃圾回收(垃圾回收期只知道释放那些new分配的内存)
        (2)垃圾回收并不等于“析构”(销毁对象)
        (3)垃圾回收只与内存有关
    6.可变参数：
        void test() (Object... o) {}
    7.枚举(枚举顺序也可查看):
        public enum data {
            a,b,b
        }
第6章 访问权限控制
    1.导入类/库：import java.util.*
    2.public protected default private
第7章 复用类
    1) 组合：使用而不破坏类
    2) 继承：丰富而不破坏类
    3) 代理：组合和继承之间的中庸之道(继承+组合)
    使用方式：被继承类：(对象)成员变量私有化，方法public
    要学会继承和组合之间的“中庸之道”
    1.初始化引用位置：
        1) 定义对象的位置
        2) 类的构造器中
        3) 使用对象前(惰性初始化：建议使用)
        4) 实例初始化
    2. 继承类中的构造器，父类最先执行
    3. 向上转型
        通过继承关系，在子类中调用父类对象的子类实例
    4.final关键字
        可修饰变量、参数、方法、类
第8章 多态
    1) 多态：动物(猫，狗，老虎) 用来维护代码的可扩展性
    2) 构造器在多态的情况下，构造器不断递归直至调用基类
    3) 构造器的主要功能用于创建对象，赋值
    4) 继承和组合优先选择组合，不会陷入层级的继承关系中，且更加灵活
    5) 继承/组合：继承是表达了行为间的差异，组合类实现行为之间的状态切换
第9章 接口
    1) 抽象类和接口的区别
    2) 策略模式：创建一个能够根据所传递的参数对象的不同而具有不通行为的方法(接口的设计也用到了策略模式)
                策略：就是传递进去的参数对象Processor
                     public static void process(Processor p,Object s){
                        print(p.process(s))
                     }
    3) 适配器模式：适配器中将接受你所拥有的所有的接口，并产生你所需要的接口
                适配：将外部所有接口以外部参数形式Filter传入,调用时包裹接口对象
                     Apply.process(new FilterAdapter(new LowPass(1.0)),w)
    4) 工厂方法模式
第10章 内部类
    -- 跳过
第11章 持有对象(容器)[查看底层实现]
    Collection: List、Set、Map、Queue
    List：
        ArrayList（经常查询使用）、LinkedList（经常编辑使用）
    Set:
        HashSet、LinkedHashSet、TreeSet
    Map:
        HashMap、TreeMap、LinkedHashMap
    Queue:
        -- 跳过
第12章 通过异常处理错误
    try{}catch(){} 和 throw 的区别在于，是否终止当前执行程序返回异常信息
    自定义异常
    -- 跳过
第13章 字符串
    String对象是不可变的
    尽量使用StringBuilder，而不是StringBuffer/String
第14章 类型信息(反射)
    1.反射的三种实现方式：
        第一种：通过Object类的getClass方法
            Class cla = foo.getClass();
        第二种：通过对象实例方法获取对象     (建议)
            Class cla = foo.class;
        第三种：通过Class.forName方式
            Class cla = Class.forName("xx.xx.Foo");
    2.instance of: 用来判断类型是否《相似》、可以预防ClassCastException() == Class.isInstance()
    3.反射：可获取运行时类信息
    4.动态代理：cglib
第15章 泛型 (更加灵活的容器类)
    1.写通用代码需要用到什么？就是泛型(配合多态)
    2.泛型方法
        public <T> void f(T t){
            printf(t.getClass().getName());
        }
        public <K,V> Map<K,V> f(){
            return new HashMap<K,V>();
        }
    3.泛型与可变参
        类比Arrays.asList()
        public static <T> List<T> makeList(T... args){
            List<T> result = new ArrayList<T>();
            for(T item: args){
                result.add(item);
            }
        }
    4.class<?>对象、generator生成器、泛型 => 构建对象生成器
        public class BasicGenerator<T> implements Generator<T> {
            private Class<T> type;
            public BasicGenerator(Class<T> type){
                this.type = type
            }
            public T next(){
                return type.newInstance();
            }
            public static <T> Generator<T> create(Class<T> type){
                return new BasicGenerator<T>(type);
            }
        }
        //调用生成器
        public static void main(String [] args){
            Generator<CountedObject> gen = BasicGenerator.create(CountedObject.class);
            for(int i=0;i<3;i++){
                printf(gen.next())
            }
        }
        //输出结果
        CountedObject CountedObject CountedObject
    5.clazz：
        工厂对象可以通过 A.class、a.newInstance() 来便利的创建新的对象
    6.边界：使得可以在泛型的参数类型上面设置限制条件
        class A <T extends B & C & D>
    7.通配符：使得参数类型可以进行向上转型
        List<? extends Fruit> flist = new ArrayList<Apple>();  ==  <T extends Fruit>
    8.逆变（超类型通配符）
        <? super MyClass> 而不是 <T super MyClass>
    9.泛型的局限性
        9.1) 不能使用基本类型用作类型参数 ArrayList<int>
    10.自限定泛型类型
        public class Basic<T> {
            T element;
            void set(T arg) {element = arg}
            T get(){ return element}
            void f(){ printf(element.getClass().getSimpleName());}
        }
    11.装饰器设计模式
        定义：使用分层对象来动态透明的向单个对象添加责任
    12.适配器设计模式
        定义：从我们拥有的接口中编写代码来产生我们需要的接口
第16章 数组
    1.数组为何特殊
        数组是一种效率最高的存储和随机访问对象引用序列的方式
    2.Arrays.fill()
        整个数组长度内的值均为填充的一样的值
    3.Arrays工具类的源码学习
    4.Arrays实用功能
        4.1) 复制数组 System.arraycopy()
        4.2) 比较数组是否相同 Arrays.equals(a,b)
        4.3) 数组排序 Arrays.sort()
        4.4) 在已排序好的数组中查找数据 Arrays.binarySearch()
        4.5) TreeSet (保持排序顺序) 和LinkedHashSet (保持插入顺序)
    5.程序设计的基本目标是：将保持不变的事物与会发生改变的事物相分离
第17章 容器深入研究
    1.享元设计模式、模板方法设计模式
    2.equals()和hashcode() 底层原理以及什么时候使用
    3.List：ArrayList、LinkedList
    4.Set：HashSet、TreeSet、LinkedHashSet、SortSet
    5.Map：HashMap、TreeMap、LinkedHashMap、WeakHashMap、ConcurrentHashMap、IdentityHashMap
    6.HashMap使用"散列码"(hashcode())提升搜索速度
    7.HashMap为何取代了HashTable
    8.散列的目的：想要使用一个对象(较快的)查找另一个对象
    9.HashMap的查询为何会如此之快
    10.为什么会遗弃HashTable、Vetor、Stack
    11.容器之间区别：通常归结于什么数据结构接口在背后做支撑
    12.每种容器都有其 (擅长) 的部分比如ArrayList(数组)用于查询操作、LinkedList(链表)用于插入和删除操作
    13.HashMap的性能因子
        容量：map的总容量
        初始容量：map在创建时的容量
        尺寸：当前存储的容量
        负载因子：当前存储的容量/map的总容量
    14.java.util.Collections静态方法 源码学习
        reverse()/reverseOrder() 反转/排序
        max()/min() 最大/最小
        sort() 排序
        swap() 元素位置交换
        disjoint() 判断两个list是否有相同元素
第18章 java IO系统
    1.输入/输出流
        inputstream/reader、outputstream/writer：用于读取/写入单个字节或者字节数组
    2.装饰器设计模式
    3.inputstream类型 (面向字节流)
        StringBufferInputStream/fileinputstream/filterinputstream
    4.outpurstream类型 (面向字节流)
        fileoutputstream/filteroutputstream
    5.reader类型 (面向字符流)
    6.writer类型 (面向字符流)
    7.适配器设计模式
        如：inputstreamreader可以把inputstream转换为reader
        如：outputstreamreader可以把outputstream转换为writer
    8.提高效率的NIO
第19章 枚举类型
    1.values()
        返回enum实例的数组
        public enum Space(){
            SCOUT,CRAGO;
            for(Space s:values()){
                printf(s);
            }
        }
    2.常量类使用
        enum Signal { GREEN,RED }
        printf(Signal.RED)
    3.随机选取枚举常量
        public class Enums{}
            private static Random rand = new Random(47)
            public static <T extends Enum<T>> T random(Class<T> ec){
                return random(ec.getEnumConstants())
            }
            public static <T> T random(T[] values){
                return values[rand.nextInt(values.length)]
            }
        }
        enum Activity { STRING,LINT,RADING}
        public class RandomTest{
            public static void main(String [] args){
                printf(Enums.random(Activity.class)+" ")
            }
        }
    4.不能从enum中删除或添加元素
    5.EnumSet、EnumMap
    6.命令设计模式
        策略设计模式完成后、程序员构造命令对象，在需要的时候调用即可
    7.职责链设计模式
        一个问题有多种解决方案，然后将这些方案链接在一起，当一个请求到来时，遍历职责链，直到链中的某个解决方案能够处理该请求
第20章 注解
    1.为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据
    2.定义注解
        @Target：定义你的注解将用于什么地方(方法/域)
        @Rectention：定义该注解在哪一个级别可用(source源代码、class类文件、runtime运行时)
    3.注解元素看起来就像接口的方法，唯一区别就是你可以为其制定默认值
    4.java内置3种标准注解、以及4中元注解 (负责注解其他注解)
        @Documented：将此注解包含在javadoc
        @Inherited：允许子类继承父类中的注解
        标准注解：@Override、@Deprecated、@SuppressWarnings
    5.仅仅编写自定义注解还够, 还需要编写注解处理器 (反射获取注解)
    6.自定义注解默认值：不能为null、不能为不确定的值 (一般-1/“”)
    7.自定义注解的理解
        可以查阅easypoi插件中对字段的注解
        可以查阅junit中@Test
    8.注解不支持继承
    9.观察者设计模式
第21章 并发
    1.并发：区别于之前的顺序编程 (并发执行)
    2.servlet是天生的多线程
    3.实现并发最直接的方式就是在操作系统界别使用进程
    -- 未完待续 (由于实际工作并未用到过多线程，故暂时不阅)
                        </code>
                    </pre>
                </figure>
            </div>
        </div>
    </div>
</body>
    <script src="../../../js/index/jquery-3.3.1.min.js"></script>
    <script src="../../../product/bootstrap/js/bootstrap.min.js"></script>
</html>
