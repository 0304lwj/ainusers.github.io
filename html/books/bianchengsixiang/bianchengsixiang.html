<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <!--添加自适应标签-->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" shrink-to-fit=no">
        <title>甜先森</title>
        <!--title上面添加icon-->
        <link rel="shortcut icon" href="../../../images/head/head.png"/>
    </head>
    <style type="text/css">
        .contents img{margin-left: 18%}
    </style>

    <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
    <link href="../../../product/bootstrap/css/bootstrap.css" type="text/css" rel="stylesheet">
    <link href="../../../css/quanzhan/pachong/pachong.css" type="text/css" rel="stylesheet">

<body>
    <div class="containers">
        <div class="col-md-12">
            <div class="contents">
                <!--提示信息-->
                <div class="bs-example bs-example-standalone" data-example-id="dismissible-alert-js">
                    <div class="alert alert-info alert-dismissible fade in" role="alert">
                        <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button>
                        <strong>注意：参照java编程思想(第四版)</strong>
                    </div>
                </div>
                <figure class="highlight">
                    <pre>
                        <code class="language-html" data-lang="html">
第2章 万物皆对象
    1.java通过“引用”来操控对象
    2.创建的对象存储在1)寄存器 2)堆栈 3)堆 4)常量储存 5)非RAM存储
    3.new创建的对象存储在“堆”中
    4.基本数据类型存储在“堆栈”中
    5.高精度数据类型：BigInteger,BigDecimal
    6.一个类是由变量和方法组合而成的
    7.数据类型的默认值(boolean:false,int:非0)
    8.当不需要返回参数的时候使用void
    9.导入依赖类库import java.util.ArrayList
    10.static关键字，修饰通用变量/方法
    11.编码风格：类，方法，成员变量，以及对象引用均采用驼峰命名法
第3章 操作符
    1.优先级：string计算，会将+号后非string类型元素转换为string类型
    2.赋值：=右边的值赋值给左边，相应的引用指向也将更改
    3.自动递增/递减：([++a/--a]表示先执行运算再生成值),([a++/a--]表示先生成值再执行运算)
    4.==比较为对象的引用以及基本数据类型的值，equals比较的是对象的值(默认比较引用)
    5.巧妙利用短路特性(test1(0) && test(2) && test(3)当判断式为true && false时，第三个表达式将不会计算)，也可获得性能提升
    6.按位操作符：1 & 1 = true ? 1 : 0、1 | 0 = true？ 1 ： 0 (均为0才为0)、1 ^ 0 = true ? 1 : 0、1 ~ = 0 (取反)
    7.移位操作符：只能处理整数类型(增码，反码，补码)
    8.三元运算符：bolean ? true : false
    9.按位与/按位或(&/|)，逻辑与/逻辑或(&&/||)
    10.类型转换(截尾[double/float转换为int][29.7转换为int=29]),(舍入[Math.round(29.7)])
    11.数据类型提升：计算将取决于大数据类型(char/byte/short计算会自动提升为int)，(float*double=double),(int+long=long)
    12.java中没有sizeOf()
    12.java中没有goto
第4章 控制执行流程
    1.逗号操作符
        for(int i=1,j=i+10; i<5; i++,j=i*2){
            System.out.println("i = "+ i + j = " + j );
        }
    2.foreach
        for(Object x : data){}
第5章 初始化与清理
    1.构造器(类使用前，对象得到初始化)：
        class Rock (){
            Rock (){
            }
        }
    2."初始化"和“创建”类，在java中为捆绑关系，没有明显的调用关系
    3.重载
        void info () {}
        void info (String s) {}
    4.java类会自动创建无参构造器，自定义构造器(无论是否有参数)均不会创建
    5.垃圾回收：
        (1)对象可能不被垃圾回收(垃圾回收期只知道释放那些new分配的内存)
        (2)垃圾回收并不等于“析构”(销毁对象)
        (3)垃圾回收只与内存有关
    6.可变参数：
        void test() (Object... o) {}
    7.枚举(枚举顺序也可查看):
        public enum data {
            a,b,b
        }
第6章 访问权限控制
    1.导入类/库：import java.util.*
    2.public protected default private
第7章 复用类
    1) 组合：使用而不破坏类
    2) 继承：丰富而不破坏类
    3) 代理：组合和继承之间的中庸之道(继承+组合)
    使用方式：被继承类：(对象)成员变量私有化，方法public
    要学会继承和组合之间的“中庸之道”
    1.初始化引用位置：
        1) 定义对象的位置
        2) 类的构造器中
        3) 使用对象前(惰性初始化：建议使用)
        4) 实例初始化
    2. 继承类中的构造器，父类最先执行
    3. 向上转型
        通过继承关系，在子类中调用父类对象的子类实例
    4.final关键字
        可修饰变量、参数、方法、类
第8章 多态
    1) 多态：动物(猫，狗，老虎) 用来维护代码的可扩展性
    2) 构造器在多态的情况下，构造器不断递归直至调用基类
    3) 构造器的主要功能用于创建对象，赋值
    4) 继承和组合优先选择组合，不会陷入层级的继承关系中，且更加灵活
    5) 继承/组合：继承是表达了行为间的差异，组合类实现行为之间的状态切换
第9章 接口
    1) 抽象类和接口的区别
    2) 策略模式：创建一个能够根据所传递的参数对象的不同而具有不通行为的方法(接口的设计也用到了策略模式)
                策略：就是传递进去的参数对象Processor
                     public static void process(Processor p,Object s){
                        print(p.process(s))
                     }
    3) 适配器模式：适配器中将接受你所拥有的所有的接口，并产生你所需要的接口
                适配：将外部所有接口以外部参数形式Filter传入,调用时包裹接口对象
                     Apply.process(new FilterAdapter(new LowPass(1.0)),w)
    4) 工厂方法模式
第10章 内部类
    -- 跳过
第11章 持有对象(容器)[查看底层实现]
    Collection: List、Set、Map、Queue
    List：
        ArrayList（经常查询使用）、LinkedList（经常编辑使用）
    Set:
        HashSet、LinkedHashSet、TreeSet
    Map:
        HashMap、TreeMap、LinkedHashMap
    Queue:
        -- 跳过
第12章 通过异常处理错误
    try{}catch(){} 和 throw 的区别在于，是否终止当前执行程序返回异常信息
    自定义异常
    -- 跳过
第13章 字符串
    String对象是不可变的
    尽量使用StringBuilder，而不是StringBuffer/String
第14章 类型信息(反射)
    1.反射的三种实现方式：
        第一种：通过Object类的getClass方法
            Class cla = foo.getClass();
        第二种：通过对象实例方法获取对象     (建议)
            Class cla = foo.class;
        第三种：通过Class.forName方式
            Class cla = Class.forName("xx.xx.Foo");
    2.instance of: 用来判断类型是否《相似》、可以预防ClassCastException() == Class.isInstance()
    3.反射：可获取运行时类信息
    4.动态代理：cglib
第15章 泛型 (更加灵活的容器类)
    1.写通用代码需要用到什么？就是泛型(配合多态)
    2.泛型方法
        public <T> void f(T t){
            printf(t.getClass().getName());
        }
        public <K,V> Map<K,V> f(){
            return new HashMap<K,V>();
        }
    3.泛型与可变参
        类比Arrays.asList()
        public static <T> List<T> makeList(T... args){
            List<T> result = new ArrayList<T>();
            for(T item: args){
                result.add(item);
            }
        }
    4.class<?>对象、generator生成器、泛型 => 构建对象生成器
        public class BasicGenerator<T> implements Generator<T> {
            private Class<T> type;
            public BasicGenerator(Class<T> type){
                this.type = type
            }
            public T next(){
                return type.newInstance();
            }
            public static <T> Generator<T> create(Class<T> type){
                return new BasicGenerator<T>(type);
            }
        }
        //调用生成器
        public static void main(String [] args){
            Generator<CountedObject> gen = BasicGenerator.create(CountedObject.class);
            for(int i=0;i<3;i++){
                printf(gen.next())
            }
        }
        //输出结果
        CountedObject CountedObject CountedObject
    5.clazz：
        工厂对象可以通过 A.class、a.newInstance() 来便利的创建新的对象
    6.边界：使得可以在泛型的参数类型上面设置限制条件
        class A <T extends B & C & D>
    7.通配符：使得参数类型可以进行向上转型
        List<? extends Fruit> flist = new ArrayList<Apple>();  ==  <T extends Fruit>
    8.逆变（超类型通配符）
        <? super MyClass> 而不是 <T super MyClass>
    9.泛型的局限性
        9.1) 不能使用基本类型用作类型参数 ArrayList<int>
    10.自限定泛型类型
        public class Basic<T> {
            T element;
            void set(T arg) {element = arg}
            T get(){ return element}
            void f(){ printf(element.getClass().getSimpleName());}
        }
    11.装饰器设计模式
        定义：使用分层对象来动态透明的向单个对象添加责任
    12.适配器设计模式
        定义：从我们拥有的接口中编写代码来产生我们需要的接口
第16章 数组
    1.数组为何特殊
        数组是一种效率最高的存储和随机访问对象引用序列的方式
    2.Arrays.fill()
        整个数组长度内的值均为填充的一样的值
    3.Arrays工具类的源码学习
    4.Arrays实用功能
        4.1) 复制数组 System.arraycopy()
        4.2) 比较数组是否相同 Arrays.equals(a,b)
        4.3) 数组排序 Arrays.sort()
        4.4) 在已排序好的数组中查找数据 Arrays.binarySearch()
        4.5) TreeSet (保持排序顺序) 和LinkedHashSet (保持插入顺序)
    5.程序设计的基本目标是：将保持不变的事物与会发生改变的事物相分离

                        </code>
                    </pre>
                </figure>
            </div>
        </div>
    </div>
</body>
    引入外部js文件
    jquery
    <script src="../../../js/index/jquery-3.3.1.min.js"></script>
     最新的 Bootstrap 核心 JavaScript 文件
    <script src="../../../product/bootstrap/js/bootstrap.min.js"></script>
</html>
