<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <!--添加自适应标签-->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" shrink-to-fit=no">
        <title>甜先森</title>
        <!--title上面添加icon-->
        <link rel="shortcut icon" href="../../../images/head/head.png"/>
    </head>
    <style type="text/css">
        .contents img{margin-left: 18%}
    </style>

    <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
    <link href="../../../product/bootstrap/css/bootstrap.css" type="text/css" rel="stylesheet">
    <link href="../../../css/quanzhan/pachong/pachong.css" type="text/css" rel="stylesheet">

<body>
    <div class="containers">
        <div class="col-md-12">
            <div class="contents">
                <!--提示信息-->
                <div class="bs-example bs-example-standalone" data-example-id="dismissible-alert-js">
                    <div class="alert alert-info alert-dismissible fade in" role="alert">
                        <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button>
                        <strong>注意：参照深入理解java虚拟机</strong>
                    </div>
                </div>
                <figure class="highlight">
                    <pre>
                        <code class="language-html" data-lang="html">
第一章 走进java
    -- 本章可不阅
    1.跨平台：
        一次编写，到处运行 (write once run anywhere)
    2.openJDK与oracle JDK区别
        openJDK 开源、oracle JDK 商用闭源
        大致代码均公用，除了极少sun公司也无权开放的代码外，基本一致
第二部分 自动内存管理机制
    第二章 java内存区域与内存溢出异常
        1.内存动态分配、垃圾收集技术
        2.虚拟机自动内存管理
            ->不容易出现内存泄露和内存溢出问题
            ->一旦出现内存泄露和溢出方面问题，如果不了解虚拟机如何使用内存，排查错误异常艰难
        3.运行时数据区域
            包括：方法区(Method Aera)、虚拟机栈(VM stack)、本地方法栈(native method stack)
                 堆(heap)、程序计数器(program counter register)
            3.1小结：
                程序计数器：程序执行位置的标志位(由于线程切换)
                虚拟机栈：描述java方法执行的内存模型(栈帧[主要包含堆栈的栈内存])
                本地方法栈：HotSpot虚拟机使用的本地Native方法
                java堆：唯一目的就是存放对象实例
                方法区：(class类内元素)存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
        4.程序计数器
            4.1.区域 (注意)：
                是一块较小的内存空间，此内存区域是唯一一个在java虚拟机规范中没有规定outOfMemoryError情况的区域
                即：不会出现内存溢出现象
            4.2.概念(是什么?)：
                可以看做当前线程所执行的字节码的行号标志位
                简单来讲就是程序执行位置的标志位(由于线程切换)
            4.3.引申：
                java虚拟机的多线程：通过线程轮流切换并分配处理器执行时间的方式来实现的
            4.4.为何会出现“程序计数器”
                任何一个确定的时刻，一个处理器(多核处理器指一个内核)都只会执行一条线程中的指令
                为了线程切换后能够恢复到正确的执行位置，故每条线程都需要一个独立的程序计数器
                且每条线程之间计数器互不影响，独立存储
            4.5.字节码解释器
                字节码解释器需要依赖程序计数器，改变程序计数器的值，来选取吓一跳需要执行的字节码指令
                分支、循环、跳转、异常处理、线程恢复等
            4.6.程序计数器记录的是什么
                如果当前线程正在执行一个java方法：计数器记录的是正在执行的虚拟机字节码指令的地址
                如果正在执行的是Native方法，这个计数器的值为空(undefined)
        5.java虚拟机栈
            5.1.生命周期
                同程序计数器相同，线程私有，java虚拟机栈的生命周期与线程相同
            5.2.描述对象(作用)
                虚拟机栈描述的是java方法执行的内存模型
                每个方法在执行的同时都会创建一个栈帧(stack frame)
                栈帧：用于存储：局部变量表(堆栈的栈)、操作数栈、动态链接、方法出口等信息
                每一个方法从调用直至执行完成，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
            5.3.栈帧概念
                每一个方法运行的同时都会创建一个栈帧，结构为栈，联系为帧，方法调用方法，帧挨着帧，故为栈帧
            5.3.java内存
                大致可以分为堆内存(Heap)和栈内存(stack)，因为这两块内存区域与对象内存分配关系最为密切
                而栈内存(stack)：指的就是运行时数据区域中虚拟机栈中的局部变量表部分
            5.4.局部变量表：
                存放了编译期间可知的8大基本数据类型(boolean、byte、char、short、int、float、long、double)
                对象引用(reference类型)和returnAddress类型
            5.5.局部变量表的大小
                局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，
                该方法需要在帧中分配多大的局部变量空间完全确定,且在方法运行期间不会改变局部变量表的大小
                小结：方法运行期间，栈的大小不会改变，因为在编译期间已经固定
            5.6.java虚拟机规范
                第一种异常：当线程请求的栈深度大于虚拟机锁允许的深度，将抛出stackoverflowerror异常
                第二种异常：当动态扩展的虚拟机，扩展是无法申请到足够的运行时内存，将抛出outofmemoryerror异常
        6.本地方法栈
            6.1.本地方法栈和虚拟机栈区别
                虚拟机栈：为虚拟机执行java方法(字节码)服务
                本地方法栈：为虚拟机使用到的Native方法服务
            6.2.虚拟机规范
                对本地方法栈中方法使用的语言、使用方式、数据结构并没有强制规定
                比如：Sun HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一
                     所以和虚拟机栈一样，本地方法栈区域也会抛出stackoverflowerror和outofmemoryerror异常
        7.java堆
            7.1.生命周期
                java堆(java heap)是java虚拟机锁管理的内存中最大的一块
                java堆被所有线程共享的一块内存区域，虚拟机启动时创建
            7.2.作用
                java堆内存区域的唯一目的就是存放对象实例，(不是所有)几乎所有的对象实例都在这里分配内存
            7.3.java堆 ≈ GC堆
                java堆是垃圾收集器管理的主要区域，因此很多时候也被称作GC堆
                现在垃圾收集器基本都采用分代收集算法
            7.4.小提示
                无论如何划分java对的内存区域，都与存放的内容无关，无论哪个区域，存储的都是对象实例
                进一步的划分的目的：是为了更好的回收内存，或者更快的分配内存
            7.5.java虚拟机规范
                java堆可以处理物理上不连续的内存空间，只要逻辑上是连续的即可
                当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)
                如果堆内没有内存完成实例分配，并且堆也无法再扩展时，将会抛出outofmemoryerror错误
        8.方法区
            8.1.生命周期
                方法区和java堆一样，是各个线程共享的内存区域
            8.2.作用
                存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
            8.3.方法区 ≈ 非堆(Non-Heap)
            8.4.方法区 ≈ 永久代
                GC分代收集使用永久代来实现方法区，Hotspot虚拟机的垃圾收集器就可以像管理其他java堆一样
                管理这部分内存，且能够省去专门为方法区编写内存管理代码，但是现在看来容易产生内存溢出问题
                所以目前已有放弃永久代并逐步采用Native Memory来实现方法区的规划
            8.5.方法区垃圾收集
                和java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集
            8.6.方法区的垃圾收集目标
                主要是针对常量池的回收和堆类型的卸载(类型卸载条件较为苛刻)
            8.7.java虚拟机规范
                当方法区无法满足内存分配要求时，将抛出outmemoryerror异常
        9.运行时常量池
            9.1.从属
                运行时常量池是方法区的一部分
            9.2.作用
                用于存放编译器生成的各种字面量和符号引用和直接引用
            9.3.java虚拟机规范
                由于从属与方法区，所以当常量池无法申请到足够的内存时会抛出outofmemoryerror异常
        10.直接内存
            10.1.从属
                直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域
            19.2.直接内存与NIO之间的关系
            19.3.内存限制
                直接内存的分配并不会收到java堆大小的限制，但是既然是内存，
                就会受到本机总内存(RAM以及SWAP交换分区)以及处理器寻址空间的限制
            19.4.outofmemoryeror异常
                由于不属于java虚拟机规范中定义的内存区域，所以不需要遵守java虚拟机规范
                但是服务器管理员在设置虚拟机参数时，会根据实际内存设置-Xmx等参数，经常忽略直接内存
                所以值得各个内存区域总和大于物理内存限制(物理内存和操作系统级别限制)，从而outofmemoryError
        11.HotSpot虚拟机
            11.1.环境
                HotSpot虚拟机在java堆中对象分配、布局、访问过程
            11.2.对象创建
                        </code>
                    </pre>
                </figure>
            </div>
        </div>
    </div>
</body>
    <!--引入外部js文件-->
    <!--jquery-->
    <script src="../../../js/index/jquery-3.3.1.min.js"></script>
    <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
    <script src="../../../product/bootstrap/js/bootstrap.min.js"></script>
</html>
