<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <!--添加自适应标签-->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" shrink-to-fit=no">
        <title>甜先森</title>
        <!--title上面添加icon-->
        <link rel="shortcut icon" href="../../../images/head/head.png"/>
    </head>
    <style type="text/css">
        .contents img{margin-left: 18%}
    </style>

    <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
    <link href="../../../product/bootstrap/css/bootstrap.css" type="text/css" rel="stylesheet">
    <link href="../../../css/quanzhan/pachong/pachong.css" type="text/css" rel="stylesheet">

<body>
    <div class="containers">
        <div class="col-md-12">
            <div class="contents">
                <!--提示信息-->
                <div class="bs-example bs-example-standalone" data-example-id="dismissible-alert-js">
                    <div class="alert alert-info alert-dismissible fade in" role="alert">
                        <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button>
                        <strong>注意：参照 “深度学习实践(计算机视觉)”</strong>
                    </div>
                </div>
                <figure class="highlight">
                    <pre>
                        <code class="language-html" data-lang="html">
前言
    1.人工智能、机器学习、深度学习?
        深度学习是机器学习的一个子领域、机器学习属于人工智能的研究范围
    2.人工智能应用场景
        计算机视觉、自然语言处理、语音处理
    3.人工智能资料
        周志华、吴恩达、李飞飞、林轩田、李宏毅等人教程
    4.未涉及OCR、目标追踪、三维重建、光场
    5.知识储备
        线性代数、概率论、统计学、高等数学、机器学习、深度学习、python、linux
第一章 深度学习与计算机视觉
    1.对于计算机来说、一切皆为数字
    2.机器学习类型
        监督学习、非监督学习、半监督学习
    3.图像基础
        3.1.图像的最基础组成单元是像素
        3.2.1920x1080
            1920列、1080行
        3.3.图像
            RGB图像 = 三通道彩色
            灰度图 = 单通道图像
        3.4.图像分类
            模拟图像(值域连续)、数字图像(值域离散)
    4.深度学习与神经网络基础
        4.1.深度学习
            将一种表示转换为另外一种表示
        4.2.神经网络
            简单来说神经网络就是一个(线性变换/非线性变换)函数
            y = f(x)   //通过输入获取输出
        4.3.深层神经网络
            a(next) = ∂(W(now) * a(previous) + b(now))
            注意：每一层的参数W和b的具体内容不同
        4.4.神经网络学习过程
            如何确定神经网络中每一层的参数(w和b)?
            题海战术(自我学习的过程)
            之后通过参数更新算法(如梯度下降算法)、不断重复学习的过程
        4.5.神经网络问题
            理想情况：训练趋势和测试趋势应差距越来越小       //题海战术表现优秀、模拟考试同样优秀
            欠拟合：训练趋势越来越大                       //题海战术都不会、模拟考试更不会
            过拟合：训练趋势越来越小、测试趋势越来越大       //题海战术很优秀、模拟考试很差劲
        4.6.训练模型
            神经网络举一反三的能力通常被称作模型 (训练好的神经网络)
        4.7.训练模型泛化能力
            训练神经网络的目标就是训练集表现优秀、测试集的泛化能力同样优秀
    5.卷积神经网络CNN
        5.1.CNN操作
            保持空间信息的线性乘法操作就是CNN操作
        5.2.CNN卷积过程
<img src="CNN卷积.gif" style="width: 53vw;height: 100vh;margin-left: 11%">
            解释：
                CNN会以固定大小的卷积核去扫描整张图片、每次扫描的区域内重复做上述的线性变换操作(参数矩阵W * 输入向量x)
                然后输出一个像素点、扫描出许多的像素点组成的特征图即为 feature map
        5.3.名词解释
            卷积核：参数矩阵w (图中input volume中选中的蓝色区域矩阵)
            核大小：参数矩阵中每行的长 * 宽 即3 * 1
            输出通道数：参数矩阵中的行数 即3、还可能为64、128、512
            输入通道数：一般有上层输入变量决定、此处为输入向量x 即w0/w1
                      现实的神经网络中经常是上一层的输出作为下一层的输入、所以输入和输出是针对某一层来说的
            边缘填充(padding)：为了捕获边缘信息而产生的手段、一般是在边缘的一行或列添0进行填充
            步长：卷积核每次扫描锁移动的像素点数、一般有水平和垂直两个方向、如上为水平2个像素点
        5.4.卷积操作输入输出尺寸公式
<img src="CNN公式.jpg" style="width: 53vw;height: 10vh;margin-left: 11%">
            解释：
                W2是卷积后Feature Map的宽度；W1是卷积前图像的宽度；F是filter的宽度；
                P是Zero Padding数量，Zero Padding是指在原始图像周围补几圈0，
                如果P的值是1，那么就补1圈0；S是步幅；
                下面为高度，类比即可
        5.5.激活函数
            常用ReLU、sigmoid等函数
        5.6.Pooling(池化层)
<img src="CNN池化.png" style="width: 53vw;height: 50vh;margin-left: 11%">
            解释：
                本质上也是卷积操作、但是不同于常规的线性变换
                在相应的区域内提取最大值、平均数(最小值少见)、如图上所示
        5.7.卷积串联组合
<img src="CNN.png" style="width: 53vw;height: 50vh;margin-left: 11%">
        5.8.网络模型
            Xception、VGG、ResNet、Inception等
        5.9.CNN优点
            保持了输入变量的空间特性、同时大大减小神经网络的参数数量、最终的效果也非常好
        5.10.神经网络
            一般包含两部分：前面的特征提取层 + 后面的任务层、通常综合一起训练
            从而实现从输入到输出的端到端(end to end)训练
        5.11.神经网络学习过程
            CNN通过不断添加网络层的方式、达到层级学习训练的效果、也就是模仿的学习过程
第二章 opencv入门
        简介：opencv (open source computer vision / 开源计算机视觉)
        1.opencv模块
            核心函数模块：高维矩阵结构及处理函数
            图像处理模块：线性和非线性滤波(卷积操作)、几何变换、颜色空间转换和像素统计
            视频模块：主要用作视频分析、运动预估、北京消除和目标追踪
            3D校准模块：多视角算法、相机校准、姿势估计等
            2D特征模块：包含显著特征检测、描述等
            目标检测模块：进行预定义类的目标检测
        2.读图、展示和保存新图
            读图/展示/保存：cv2.imread()/cv2.imshow()/cv2.imwrite()
        3.代码示例
            import cv2
            //导入图片
            image = cv2.imread('test.jpg')
            //opencv采用的格式为H*W*C (高度*宽度*通道数) 顺序为BGR、python的pillow库则为RGB
            print(image.shape[0])       //height
            print(image.shape[1])       //width
            print(image.shape[2])       //channels

            cv2.imshow('Image',image)
            cv2.waitKey(0)     //按键后0毫秒执行

            cv2.imwrite('new_image.jpg',image)
        4.像素点及局部图像
            概念：
                像素点：即图片上面的坐标位置
                局部图像：以左上角为(0,0)原点、向下向右为正
                opencv读取图片后返回的是一个Numpy矩阵对象
            实际操作：
                            image = cv2.imread('image.jpg')
                1.获取距离左上角距离为(10,10)的像素值：
                            (b,g,r) = image[10,10]
                            print(b,g,r)
                2.改变距离左上角距离为(10,10)的像素值：
                            image[10,10] = (255,255,0)
                3.获取局部图像 (切片思想)：
                            patch = image[0:100,0:100]
                            image[0:100,0:100] = (0,255,255)    //修改局部图像颜色
                            cv2.imshow('patch',patch)           //展示
            注意：所有的参考点均为左上角原点(0,0)
        5.基本线条 (看似画线条、画矩形、画圆并无卵用、但是在人眼识别、人脸识别上面可作范围划分)
            1.画矩形
                canvas = np.zeros((300,300,3),dtype='uint8')    //渲染黑色背景
                cv2.rectangle(canvas,(100,100),(50,50),(0,255,0),2)     //画框

                cv2.imshow('canvas',canvas)
                cv2.waitKey(0)
        6.平移
            1.将图片上下左右移动 (主要参数为含有方向和距离的平移矩阵)
                image = cv2.imread('image.jpg')

                M = np.float32([[1,0,75],[0,1,70]])     //最终向右移动75像素、向下移动70像素
                shifted_image = cv2.warpAffine(image,M,(image.shape[1],image.shape[0]))

                cv2.imshow('shifted_image',shifted_image)
                cv2.waitKey(0)
        7.旋转
            1.即以图片某点为圆心、并按照某角度顺时针或逆时针旋转
                image = cv2.imread('image.jpg')

                (h,w) = image.shape[:2]
                center = (w//2,h//2)

                M = cv2.getRotationMatrix2D(center,90,1.0)      //旋转固定点、旋转角度、缩放尺度
                Rotated_image = cv2.warpAffine(image,M,(w,h))

                cv2.imshow('Rotated_image',Rotated_image)
                cv2.waitKey(0)
        8.缩放 (缩小和放大)
            1.缩小：删除其中某些像素、直至达到需要缩小的目标尺寸、存在信息丢失现象
            2.方法：在图像中添加一些像素、使图像变大到目标尺寸
            3.插值：寻找最优删除或添加像素值的方法
                image = cv2.imread('image.jpg')

                new_w,new_h = 400,400
                resized_image = cv2.resize(image,(new_w,ne  w_h),interpolation=cv2.INTER_AREA)

                cv2.imshow('resized_image',resized_image)
                cv2.waitKey(0)
            4.常用的插入值选项
                cv2.INTER_AREA
                cv2.INTER_LINEAR
                等9种可选值
                对于OpenCV而言、官方建议放大使用：cv2.INTER_LINEAR、缩小使用cv2.INTER_AREA
        9.翻转
            1.分为水平翻转和垂直翻转
                image = cv2.imread('image.jpg')

                flipped_shuiping_chuizhi = cv2.flip(image,-1)
                flipped_chuizhi = cv2.flip(image,0)
                flipped_shuiping = cv2.flip(image,1)

                cv2.imshow('flipped_shuiping_chuizhi',flipped_shuiping_chuizhi)
                cv2.imshow('flipped_chuizhi',flipped_chuizhi)
                cv2.imshow('flipped_shuiping',flipped_shuiping)
                cv2.waitKey(0)
        10.裁剪
            1.直接使用Numpy的切片操作
                image = cv2.imread('image.jpg')

                cropped_image = image[250:500,250:500]

                cv2.imshow('cropped_image',cropped_image)
                cv2.waitKey(0)
        11.算数操作
            对图像做任何操作谨记图像取值范围及数值类型、对于RGB来说，值为[0,255]中的一个整数
        12.位操作
            1.交集、并集、异或、非操作
                # 矩形
                rectangle = np.zeros((100,100),dtype='uint8')
                cv2.rectangle(rectangle,(30,30),(70,70),255,-1)
                cv2.imshow('rectangle',rectangle)
                # 圆形
                circle = np.zeros((100,100),dtype='uint8')
                cv2.circle(circle,(50,50),25,255,-1)
                cv2.imshow('circle',circle)

                #and
                birwiseAnd = cv2.bitwise_and(rectangle,circle)
                cv2.imshow('and',birwiseAnd)

                #or
                birwiseOr = cv2.bitwise_or(rectangle,circle)
                cv2.imshow('or',birwiseOr)

                #xor
                birwiseXOr = cv2.bitwise_xor(rectangle,circle)
                cv2.imshow('xor',birwiseXOr)

                #not
                birwiseNot = cv2.bitwise_not(circle)
                cv2.imshow('not',birwiseNot)

                cv2.waitKey(0)
        13.Msking操作 (遮罩效果)
            1.遮罩Making和Numpy切片裁剪不同 (mask保持了原有坐标位置信息，只是遮盖了其他地方视野)
                image = cv2.imread('image.jpg')
                cv2.imshow('image',image)

                mask = np.zeros(image.shape[:2],dtype='uint8')
                (cX,cY) = (image.shape[1] // 2,image.shape[0] // 2)
                cv2.rectangle(mask,(cX-75,cY-75),(cX+75,cY+75),255,-1)
                cv2.imshow('mask',mask)

                maked = cv2.bitwise_and(image,image,mask=mask)
                cv2.imshow('maked',maked)
                cv2.waitKey(0)
        14.色彩通道分离与融合
            1.主要是针对RGB、3层色彩通道分离、分离主要使用solit()融合则用merge()
                image = cv2.imread('image.jpg')

                (B,G,R) = cv2.split(image)
                merged = cv2.merge([B,G,R])

                cv2.imshow('RED',R)
                cv2.imshow('GREEN',G)
                cv2.imshow('BLUE',B)
                cv2.imshow('MERGE',merged)
                cv2.waitKey(0)
        15.颜色空间转换
            1.颜色空间介绍 (有很多类别、如之前的RGB、此外还有HSV [H：色调，S：饱和度，V：明度]、L * a * b)
            2.openCV支持超过150中颜色空间
            3.颜色空间转换主要是：gray、hsv、lab之间转换
                image = cv2.imread('image.jpg')
                cv2.imshow('original',image)

                gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
                cv2.imshow('gray',gray)

                hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)
                cv2.imshow('hsv',hsv)

                lab = cv2.cvtColor(image,cv2.COLOR_BGR2LAB)
                cv2.imshow('lab',lab)

                cv2.waitKey(0)
        16.平滑与模糊 (主要用于边缘检测)
            1.平滑与模糊：即失去焦点、致使看不到图像细节
            2.常用的平滑方法：均值、高斯、中值、双边 (没看出有啥子区别)
                image = cv2.imread('image.jpg')

                blurred = np.hstack([
                    cv2.blur(image,(3,3)),
                    cv2.blur(image,(5,5)),
                    cv2.blur(image,(7,7))
                ])
                cv2.imshow('aberages',blurred)

                blurred = np.hstack([
                    cv2.GaussianBlur(image,(3,3),0),
                    cv2.GaussianBlur(image,(5,5),0),
                    cv2.GaussianBlur(image,(7,7),0)
                ])
                cv2.imshow('gaussian',blurred)

                blurred = np.hstack([
                    cv2.medianBlur(image,3),
                    cv2.medianBlur(image,5),
                    cv2.medianBlur(image,7)
                ])
                cv2.imshow('median',blurred)

                blurred = np.hstack([
                    cv2.bilateralFilter(image,5,21,21),
                    cv2.bilateralFilter(image,7,31,31),
                    cv2.bilateralFilter(image,9,41,41)
                ])
                cv2.imshow('bilateral',blurred)

                cv2.waitKey(0)
                        </code>
                    </pre>
                </figure>
            </div>
        </div>
    </div>
</body>
    <!--引入外部js文件-->
    <!--jquery-->
    <script src="../../../js/index/jquery-3.3.1.min.js"></script>
    <!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
    <script src="../../../product/bootstrap/js/bootstrap.min.js"></script>
</html>
